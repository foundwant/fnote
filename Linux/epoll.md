# epoll

[TOC]


##### epoll的产生以及原理
　　
　　首先我们明确几个术语和定义
> 
* 流：Linux一切皆文件，所有的操作都是通过文件描述符完成；
* 阻塞
* 用户态缓冲区和内核缓冲区

　　我们来定义流的概念，一个流可以是文件，Socket，Pipe等可以进行I/O操作的内核对象；不管是文件，套接字还是管道，我们都把它看作流；
　　之后我们来讨论I/O的操作，通过read我们可以从流中读入数据；通过write我们可以向流中写入数据。
　　现在假设一种情形，我们需要从流中读取数据，但是流中没有数据，这时候该怎么办？(典型的例子，客户端从socket读取数据，但是服务器没有把数据返回来)
　　__阻塞__是什么概念？比如某个时候你在等快递，但是你不知道快递什么时候会来，而且你又没有别的事情可以做；那么你可以去睡觉了，因为你知道快递把货送来时一定会给你打电话。
　　__非阻塞忙轮询__：接着上面的例子，如果用忙轮询的方法，那么你需要知道快递员的电话，然后每分钟给他打电话：“你到了没有？”
　　很明显一般人不会用第二种方法，不仅浪费话费，还占用了快递员的大量时间。
　　大部分程序也不会用第二种方法，因为第一种方法经济又简单，经济是指消耗很少的CPU时间，如果线程睡眠了，就调出了系统的调度队列，暂时不会瓜分CPU宝贵的时间片了。
　　为了了解阻塞时如何进行的，我们来讨论__缓冲区__以及__内核缓冲区__，最终把I/O事件解释清楚。
　　缓冲区的引入是为了减少频繁的I/O操作而引起频繁的系统调用，众所周知系统调用很慢的，当你操作一个流时，更多的是以缓冲区为单位进行操作，这是相对于用户空间而言。对于内核来说，也需要缓冲区，下面我们做一个假设：
　　假设有一个管道，两个进程A和B，进程A为管道的写入方，进程B为管道的读出方；
　　假设一开始内核缓冲区是空的，进程B作为读出方被阻塞着；首先，进程A向管道写入数据，内核缓冲区由空状态变成非空状态，这时内核就会产生一个事件告诉进程B：“你该醒来了”，这个事件我们暂且称之为__“缓冲区非空”__事件；但在“缓冲区非空”事件通知进程B之后，进程B却没有开始读数据，且我们假设内核许诺不能把写入管道中的数据丢掉，这个时候进程A写入的数据会滞留在内核缓冲区中。如果内核缓冲区满了，进程B仍未开始读取数据，最终内核缓冲区会被填满，这个时候内核会产生一个I/O事件，告诉进程A：“你该等等了（阻塞）”，我们暂且把这个事件定义为__“缓冲区满”__；最后进程B终于开始读取数据了，于是内核缓冲区空了出来，这时候内核会告诉进程A：“内核缓冲区有空位了，你可以醒来继续写数据了”，我们把这个事件叫做__“缓冲区非满”__；事件已经通知了进程A，但是进程A却没有数据可写入了，而进程B又在继续读取数据，直到内核缓冲区空了，这个时候内核就告诉进程B：“你需要阻塞了”，我们暂且把这个事件定义为__“缓冲区空”__；
　　以上着四种情形，涵盖了四个I/O事件，__缓冲区满，缓冲区空，缓冲区非空，缓冲区非满__（这里的缓冲区都是指的内核缓冲区），这四个I/O事件是进行阻塞同步的根本。
　　然后我们来说说阻塞I/O的缺点。阻塞I/O模式下，一个线程同一时刻只能处理一个流的I/O事件。如果想同时处理多个流，要么多进程（fork），要么多线程(pthread_create)，然而这两种方式效率都不高；于是再来考虑非阻塞忙轮询的I/O方式，这时发现我们可以同时处理多个流了，方式如下：
  ```Lua
  	while true{
		for i in stream[];
		{
			if i has data
				read until unavailable;
		}
	}
  ```
　　从上面的流程可以看出，我们只需要不停的把所有的流从头到尾循环的问一遍，又从头开始......；这样就可以处理多个流了，但这样的做法很显然不好，因为如果所有的流都没有数据，那么只会白白浪费CPU。这里要补充一点，在阻塞模式下，内核对于I/O事件的处理是要么阻塞要么唤醒，而非阻塞模式下则把I/O事件交给其它对象处理（这里的其它对象就是我们后续介绍的select以及poll）甚至直接忽略掉；
　　为了避免CPU空转，所以引进了一个代理，一开始有个叫select的代理，后来又有一个poll的代理，不过两者的本质都一样的。这个代理比较厉害，可以同时观察许多流的I/O事件，在空闲的时候，会把当前线程阻塞掉，当有一个或者多个流有I/O事件时，就从阻塞态中醒来，于是我们的程序就会轮询一遍所有的流（这里我们可以把“忙”字去掉了）；
  ```Lua
  	while true{
		select(stream[])
		{
			for i in stream[]
			{
				if i has data
					read until unavailable;
			}
		}
	}
  ```
　　从上面的流程可以看出，如果没有I/O事件产生，我们的程序就会阻塞在select处。但是这里依然有个问题，我们从select那里仅仅知道了有I/O事件发生了，但是却并不知道是几个流（可能有一个，多个或者全部），我们只能无差别的轮询所有流，找出能读出数据或者写入数据的流，再对它们进行操作；使用select，我们有O(n)的无差别轮询复杂度，同时处理的流越多，每一次无差别轮询的时间就越长。于是乎，我们的epoll诞生了，终于进入了主题；
　　epoll可以理解为event poll，不同于__忙轮询__和__无差别轮询__，epoll只会把哪个流发生了怎样的I/O事件通知我们。此时我们对这些流的操作都是有意义的，这样时间复杂度就降低到了O(1)；在讨论epoll的实现细节之前，我们先把epoll的相关操作列出：
  ```lua
	创建一个epoll对象
	epoll_create
	
	注册事件
	epoll_ctl
	epoll_ctl(epollfd, EPOLL_CTL_ADD, socket, EPOLLIN);  //注册缓冲区非空事件，即有数据流入
	epoll_ctl(epollfd, EPOLL_CTL_DEL, socket, EPOLLOUT); //注册缓冲区非满事件，即流可被写入
	
	等待注册的事件发生
	epoll_wait
  ```
　　注：当对一个非阻塞流的读写发生缓冲区满货缓冲区空时，read/write会返回-1， 并设置errno=EAGAIN。而epoll只关心缓冲区非满和缓冲区非空事件；
　　一个epoll模型的大概样子：
  ```lua
  	while true{
		active_stream[] = epoll_wait(epollfd)
		for i in active_stream[]
		{
			read or write till
		}
	}
  ```
　　通过上面揭示，我们直到了epoll是如何诞生的以及它的原理，至于epoll的使用细节，我们后续继续揭秘。
  
　　*本文中我们提到了：流，缓冲区这两个及其重要的概念，我会在下文详细的介绍这些操作系统底层的技术及原理*
  
##### epoll细节及使用介绍

##### epoll代码示例