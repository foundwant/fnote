## Linux缓存I/O机制

##### 什么是缓存I/O（Buffered I/O）
对于传统的操作系统来说，普通的I/O操作一般会被内核缓存，这种I/O被称作缓存I/O，又称作标准I/O;
大多数文件系统的默认I/O操作都是缓存I/O。在Linxu的缓存I/O机制中，操作系统会将I/O的数据缓存在文件系统的页缓存（page cache）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。缓存I/O有以下优点：
-  缓存I/O使用了操作系统内核缓冲区，在一定程度上分了了应用程序空间和实际的物理设备；
-  缓存I/O可以减少读盘的次数，从而提高性能；

当应用程序尝试读取某块数据的时候，如果这块数据已经存放在了页缓存中，那么这块数据就可以立即返回给应用程序，而不需要经过实际的物理读盘操作。当然，如果数据在应用程序读取之前并未存放在页缓中，那么就需要先将数据从磁盘读到页缓存中去。对于写操作来说，应用程序也会将数据先写到页缓存中去，数据是否被立即写到磁盘上去取决于应用程序所采用的写操作机制：如果用户采用的是同步写机制（sysnchronoous writes），那么数据就会立即被写回到磁盘上，应用程序会一直等到数据被写完为止；如果用户采用的是延迟写机制（deferred writes)，那么应用程序就完全不需要等到数据全部被写回到磁盘，数据只要被写到页缓存中去就可以了。在延迟写机制的情况下，操作系统会定期地将放在页缓存中的数据刷到磁盘上。与异步写机制（asynchronous writes）不同的是，延迟写机制在数据完全写到磁盘上的时候不会通知应用程序，而异步写机制在数据完全写到磁盘上的时候是会返回给应用程序的。所以延迟写机制本身是存在数据丢失风险的，而异步写机制则不会有这方面的担心。

##### 缓存I/O的缺点
在缓存I/O机制中，DMA方式可以将数据直接从磁盘读到页缓存中，或者将数据从页缓存直接写回到磁盘上，而不能直接在应用程序地址空间和磁盘之间进行数据传输，这样的话，数据在传输过程中需要在应用程序地址空间和页缓存之间进行多次拷贝操作，这些数据拷贝操作所带来的CPU以及内存开销是非常大的。对于某些特殊的应用程序来说，避开操作系统内和缓冲区而直接在应用程序地址和磁盘之间传输数据会比使用操作系统内核缓冲区获取更好的性能，下边一小节中提到的自缓存应用程序就是其中的一种。

##### 自缓存应用程序（self-caching applications）
对于某些应用程序来说，它会有它自己的数据缓存机制，比如，它会将数据缓存在应用程序地址空间，这类应用程序完全不需要实用操作系统内核中的高速缓冲存储器，这类衣黄瓜用程序就被称作是自缓存应用程序(self-caching application)。数据库管理系统是这类应用程序的一个代表。自缓存应用程序倾向于使用数据的逻辑表达方式，而非屋里表达方式；当系统内存较低的时候，自缓存应用程序会让这种数据的逻辑缓存被换出，而并非是磁盘上实际的数据被换出。自缓存应用程序对要操作的数据的语义了如指掌，所以它可以采用更加高效的缓存替换算法。自缓存应用程序有可能会在多台主机之间共享一块内存，那么自缓存应用程序就需要提供一种能够有效地将用户地址空间的缓存数据置为无效的机制，从而确保应用程序地址空间缓存数据的一致性；

对于自缓存应用程序来说，缓存I/O明显不是一个好的选择。由此引出了Linux中的直接I/O技术。Linux中的直接I/O技术非常适用于自缓存这类应用程序，该技术省略掉缓存I/O技术中曹组系统内核缓冲区的使用，数据直接在应用程序地址空间和磁盘之间进行传输， 从而使得自缓存应用程序可以省略掉复杂的系统级别的缓存结构，而执行程序自己定义的数据读写管理，从而降低系统级别的管理对应用程序访问数据的影响。

##### Linux中提供的几种文件访问方式

所有的 I/O 操作都是通过读文件或者写文件来完成的。在这里，我们把所有的外围设备，包括键盘和显示器，都看成是文件系统中的文件。访问文件的方法多种多样，这里列出下边这几种 Linux 2.6 中支持的文件访问方式。
```
标识符名	标识符描述
O_RDONLY	以只读的方式打开文件
O_WRONLY	以只写的方式打开文件
O_RDWR	以读写的方式打开文件
O_CREAT	若文件不存在，则创建该文件
O_EXCL	以独占模式打开文件；若同时设置 O_EXCL 和 O_CREATE, 那么若文件已经存在，则打开操作会失败
O_NOCTTY	若设置该描述符，则该文件不可以被当成终端处理
O_TRUNC	截断文件，若文件存在，则删除该文件
O_APPEND	若设置了该描述符，则在写文件之前，文件指针会被设置到文件的底部
O_NONBLOCK	以非阻塞的方式打开文件
O_NELAY	同 O_NELAY，若同时设置 O_NELAY 和 O_NONBLOCK，O_NONBLOCK 优先起作用
O_SYNC	该描述符会对普通文件的写操作产生影响，若设置了该描述符，则对该文件的写操作会等到数据被写到磁盘上才算结束
FASYNC	若设置该描述符，则 I/O 事件通知是通过信号发出的
O_DIRECT	该描述符提供对直接 I/O 的支持
O_LARGEFILE	该描述符提供对超过 2GB 大文件的支持
O_DIRECTORY	该描述符表明所打开的文件必须是目录，否则打开操作失败
O_NOFOLLOW	若设置该描述符，则不解析路径名尾部的符号链接
```

##### 直接I/O技术的特点
###### 优点
直接 I/O 最主要的优点就是通过减少操作系统内核缓冲区和应用程序地址空间的数据拷贝次数，降低了对文件读取和写入时所带来的 CPU 的使用以及内存带宽的占用。这对于某些特殊的应用程序，比如自缓存应用程序来说，不失为一种好的选择。如果要传输的数据量很大，使用直接 I/O 的方式进行数据传输，而不需要操作系统内核地址空间拷贝数据操作的参与，这将会大大提高性能。

###### 潜在问题
直接I/O并不一定总能提供令人满意的性能上的飞跃。设置直接I/O的开销非常大，而直接I/O又不能提供缓存I/O的优势。缓存I/O的读操作可以从高速缓冲存储器中获取数据，而直接I/O的读数据操作会造成磁盘的同步读，这会带来性能上的差异，并且导致进程需要较长的时间才能执行完；对于写数据操作来说，使用直接I/O需要write()系统调用同步执行，否则应用程序将会不知道什么时候才能够再次使用它的I/O缓冲区。与直接I/O读操作类似的是，直接I/O写操作也会导致应用程关闭缓慢。所以，应用程序使用直接I/O进行数据传输的时候通常会和异步I/O结合使用。

Linux 中的直接 I/O 访问文件方式可以减少 CPU 的使用率以及内存带宽的占用，但是直接 I/O 有时候也会对性能产生负面影响。所以在使用直接 I/O 之前一定要对应用程序有一个很清醒的认识，只有在确定了设置缓冲 I/O 的开销非常巨大的情况下，才考虑使用直接 I/O。